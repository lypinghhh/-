/**
 * 【变量提升 - 预解释】
 * 在（栈内存）作用域形成之后，JS代码自上而下执行之前，
 * 浏览器首先会把所有带var 、function关键词的进行提前声明或者定义
 * 这种预先处理机制称之为 变量提升
 * => "声明" （declare）var a / function sum  (默认值undefined)
 * => "定义" （define）  a = 12;(赋值)
 * 
 * 【变量提升阶段】
 * => 带 var 的只声明未定义
 * => 带 function 的声明加赋值
 * 
 * window 全局栈内存
 * var a;
 * var b;
 * sum = AAAAA  =>  开辟空间 存储代码字符串 
 * 变量提升只发生在 当前作用域  也即刚开始加载页面，只对全局作用域下的进行提升，
 * 因为此时函数中存储的都是字符串而已
 * => 在全局作用域下声明的函数或者变量 是 全局变量 ，
 *    在私有作用于下声明的变量是 私有变量 【带var/function是声明】
 * 
 * null具有语义化 现在没有，以后进行赋值
 * 变量提升阶段完成的事情，代码执行阶段不在重复  懒
 * 当代码执行遇到创建函数这部分代码后，直接的跳过即可
 * 因为在提升阶段已经完成函数的赋值操作
 * 函数执行 
 * 1. 首先会形成私有的栈内存- 私有作用域
 * 目的是把之前存储的代码字符串，变成代码执行
 * 2.私有作用域形成之后，变量提升（变量提升前先形参赋值）
 * 3.代码执行
 * ES3、5老版本的js，
 * 只有全局作用域和函数执行的私有作用域（栈内存）
 * 只有函数可以形成私有作用域 
 * {}不能形成作用域 栈内存
 * 
 * 
 * =>
 * 变量提升机制，从严谨角度来说是不好的
 */



console.log(a); //不会报错，输出undefined
var a = 12;


