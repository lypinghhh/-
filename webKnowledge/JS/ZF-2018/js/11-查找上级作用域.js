/**
 * 当前函数执行时，形成一个私有作用域，他的上级作用域，只和创建/定义位置有关系
 * 在哪创建的，上级作用域就是谁
 * 变量提升的时候 就声明加定义了
 * =>堆栈内存释放
 * 堆内存销毁 ，引用他的变量赋值为null
 * 栈内存销毁，
 * 1.全局作用域 页面在浏览器关闭时销毁
 * 2.函数 私有栈内存 函数代码执行完毕之后，作用域没用则销毁
 *   当前栈内存中的某个东西被栈内存以外的东西占用，则不能销毁
 */


/******************TEST01************** */


var a = 12;

function fn(){
    //上级作用域--全局
    //=>arguments：实参集合 
    //=>arguments.callee:当前函数本身fn
    //=>arguments.callee.caller :当前函数在哪执行就是谁，全局的话 Null
    //caller记录的是她执行的宿主环境
    console.log(arguments.callee.caller)

    console.log(a);//**12**
}
// fn();


function sum(){
    var a = 120;
    fn();//**12**
    /**
     * 上级作用域 
     */
}

sum();

/******************TEST02************** */

/**
 * 变量提升 
 *私有变量和全局变量 的n 没有关系 闭包
 */
var n = 10;
function fn() {
    var n = 20;

    function f(){
        n++;
        //1. n为上级作用域中的n修改为21
        //2.x()n为上级作用域中的n修改为22
        //3.x()n为上级作用域中的n修改为23
        console.log(n)
    }
    f();
    return f;
    //返回函数的内存堆地
}
var x= fn();//21
//=> 把 fn执行的结赋值给x全局变量
//=> fn() 
x();//22  //操作上级
x();//23
console.log(n);//10
