/**
 * [闭包]
 * 函数执行形成一个私有的作用域
 * 保护里面的私有变量不受外界的干扰  --》保护
 * function fn(){}
 * fn();
 * 函数执行的保护机制就是闭包
 * =>
 * 市面上的开发者认为的闭包
 * 形成一个不销毁的私有作用域（栈内存）
 * 函数返回的内容，被外面变量占用 ，形成一个不销毁的栈内存
 * 
 * => 真实项目中为了保证js的性能（堆栈内存的性能优化)
 * 应该尽可能的减少闭包的使用
 * 产生一个闭包，就产生一个不销毁的栈内存=》存在不销毁的堆和栈
 * 不销毁的堆栈内存是耗性能的 
 * 
 * => 
 * 1.保护作用：保护私有变量不受外界的干扰
 * => 在真实项目中，尤其是团队协作开发的时候，应当尽可能地减少全局变量的使用，以防止相互之间的冲突（全局变量污染）
 * 
 * 那么此时，可以把自己这一部分内容封装到一个闭包中，让全局变量转换为私有变量
 * 最简单的方式 ，自执行函数把原来的函数包起来
 * 
 * （封装类库/插件方法也会存放到闭包中保护起来，防止和用户的程序冲突，但是我们有需要暴露一些方法给客户使用）
 * 暴露的处理方法：
 * A:jq这种方式：把需要暴露的方法抛到全局  $('#BOX').xxx()
 * B:
 * 2.保存作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用
 * 
 * 
 * 
 * 
 * 
 * 
 */

//闭包 示例  
//=>  闭包:柯里化函数
 function fn(){
     return function(){

     }
 }

 var f = fn();

 //=> 闭包：惰性函数
 var utils = (function(){
    return {

    }
 })()


 /***************************闭包项目实战应用 ***************************/

 //jq 避免不同的人分工写出的代码具有相同的命名，可以使用闭包
 //=> 保护

//把函数用自执行函数包起来
 (function(){

 })()

 (function(){

})()

 function fn(){

 }

 function fn(){

 }

 //jq原理
 (function(){
     function jQuery(){

     }
     //...
     window.jQuery = window.$ = jQuery
     //需要供外面使用的方法，通过给window设置属性的方式暴露出去
 })()

 jQuery();
 $();

  //Zepto 这种方式:基于return 把需要供外面使用的方法暴露出去

  
 var Zepto = (function(){
    //...
    return {
        xxx:function(){

        }
    }
  })();

  Zepto.xxx();b