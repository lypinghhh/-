/**
 * js中的内存分为堆内存和栈内存
 *  堆内存:存储引用数据类型值（对象:键值对;函数：代码字符串）
 *  栈内存：提供js代码执行的环境和存储基本类型值
 * 
 * =>
 * [堆内存释放]
 *  让所有引用对内存空间地址的变量赋值为null即可
 *  没有变量占用这个堆内存了，浏览器会在空闲的时候把他释放掉
 * [栈内存释放]
 *  一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉
 * （在栈内存中存储的值也都会释放掉）
 * 特殊不销毁的情况：
 * 1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，
 * 此时内存不能释放（一旦释放，外面找不到原有的内容了）
 * 2.全局栈内存只有在页面关闭的时候才会被释放掉
 * ...
 * 如果当前栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放，
 * 能够一直保存下来
 * 
 * =>
 * i++  自身累加1 先使用原始值运算 ，之后再进行累加1
 * ++i  自身累加1 先将自身累加1，再进行运算
 * 
 * 函数的每次执行 都是重新操作一遍 互不干扰  返回的函数都不同，每次都是重新开辟
 * 
 * [闭包]
 * 作用：
 * 1.保护机制：保护自己私有变量不受外界干扰
 * 2.保存机制：值不销毁，可以继续修改原有值
 */
var k = 1;
console.log( 5 + ++k,k)//7 2
console.log( 5 + k++,k)//6 2

var k = 1;
console.log(5+(++k)+(k++)+4+(k--)+(++k)+3+(--k)+(k++),k)
// 5 2 2 4 3 3 3 2 2  
//26 3

 /**----------------------------------------- */
var i = 1;
function fn(i){
    //不销毁 无需释放的私有作用域
    return function(n){
        //return后边是值，相当于等号右边，不进行提升
        //函数相当于新娘开辟了一个内存堆
        console.log( n + (++i));
    }
}

var f = fn(2);//=>  先把fn执行（传递实参2），把fn执行的返回结果（return后面的值赋给f）=> f()把返回的结果执行
f(3);//6
fn(5)(6)//12
//fn(2)()=> 先把fn执行，把fn执行的返回结果再次执行
fn(7)(8)//16
f(4);//上级查找  


