## 1.了解Web及网络基础

> 引入：当在浏览器的地址栏输入url时...
>
> 根据Web浏览器地址栏中指定的url，Web浏览器从Web服务端获取文件资源（resource)等信息，从而显示出Web页面。

**HTTP**（HyperText Transfer Protocol，超文本传输/转移协 议 ）

**客 户端**（client）：通过发送请求获取服务器资源的 Web 浏览器等

**WWW 构建技术**，分别是：

把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标 记语言的 HTML（HyperText Markup Language，超文本标记语言）；

 作为文档传递协议的 HTTP ；

指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。 

**TCP/IP 协议族**是互联网相关的各类协议族的总称 ，HTTP 属于它内部的一个子集。 

![](https://user-gold-cdn.xitu.io/2020/1/6/16f7b19676baacca?w=629&h=334&f=png&s=150674)

狭义：TCP/IP 是指 TCP 和 IP 这两种协议。

还有一种说法认为，TCP/ IP 是在 IP 协议的通信过程中，使用到的协议族的统称。 

##### **TCP/IP 协议族层次化**

##### 按层次分别分 为以下 4 层：应用层、传输层、网络层和数据链路层。 

**应用层**

应用层决定了向用户提供应用服务时通信的活动。

- FTP（File Transfer Protocol，文件传输协议）
- DNS（Domain Name System，域 名系统）
- HTTP 协议也处于该层。

**传输层**
传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。

- TCP（Transmission Control Protocol，传输控制协议）
-  UDP（User Data Protocol，用户数据报 协议）。

**网络层（又名网络互连层）**
网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。
与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。
**链路层（又名数据链路层，网络接口层）**
用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。

硬件上的范畴均在 链路层的作用范围之内。

**TCP/IP 通信传输流**

![](https://user-gold-cdn.xitu.io/2020/1/6/16f7b2298be9d782?w=648&h=505&f=png&s=112977)

**封装**

![](https://user-gold-cdn.xitu.io/2020/1/6/16f7b239ce62b68d?w=650&h=603&f=png&s=228482)

##### 与 HTTP 关系密切的协议 : IP、TCP 和 DNS

##### 1.负责传输的 IP 协议

IP（Internet Protocol）网际协议位于**网络层**，作用是把各种数据包传送给对方

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。

IP 地址可以和 MAC 地址进行配对。

IP 地址可变换，但 MAC 地址基本上不会更改。
使用 ARP 协议凭借 MAC 地址进行通信 ，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。

没有人能够全面掌握互联网中的传输状况

**路由选择**：在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。2.

##### 2.确保可靠性的 TCP 协议

按层次分，TCP 位于**传输层**，提供可靠的字节流服务。

 字节流服务（Byte Stream Service）是指，为了方便传输，将大 块数据分割成以报文段（segment）为单位的数据包进行管理。

可 靠的传输服务是指，能够把数据准确可靠地传给对方。

一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。

**三次握手** （three-way handshaking）策略。

用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。

握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

 发送端首先发送一个带 SYN 标志的数据包给对方。

接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。

最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。

 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。
除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠 性。 

##### 3.负责域名解析的 DNS （Domain Name System）服务

DNS（Domain Name System）服务是和 HTTP 协议一样位于**应用层**的 协议。它提供域名到 IP 地址之间的解析服务。 

DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。

![](https://user-gold-cdn.xitu.io/2020/1/6/16f7b3de217e073d?w=513&h=686&f=png&s=237008)

##### URI 和 URL

URI（ Uniform Resource Identifier 统一资源标识符）

 URL（Uniform Resource Locator，统一资源定位符）

 URL 是 URI 的子集。 

绝对 URI 的格式:

![](https://user-gold-cdn.xitu.io/2020/1/6/16f7b59727aa7411?w=866&h=179&f=png&s=122052)

**协议方案名**：使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不 区分字母大小写，最后附一个冒号（:）。 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。
**登录信息（认证）**
指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份 认证）。此项是可选项。
**服务器地址**
使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。
**服务器端口号**
指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号。
**带层次的文件路径**
指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件 目录结构相似。
**查询字符串**
针对已指定的文件路径内的资源，可以使用查询字符串传入任意参 数。此项可选。
**片段标识符**
使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个 位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选 项。

RFC（Request for Comments，征求修正意见书）是互联网的设计文档

并不是所有的应用程序都符合 RFC 

## 2.简单的 HTTP 协议

HTTP 协议用于客户端和服务器端之间 的通信。

请求访问文本或图像等资源的一端称为**客户端**，而提供资源响应的一 端称为**服务器端**。

用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器 端。 

请求必定由客户端发出，而服务器端回复响应

##### **请求报文**

是由请求方法、请求 URI、协议版本、可选的请求首部字段 和内容实体构成的。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7dfc87cd09463?w=943&h=445&f=png&s=215154)

##### **响应报文**

基本上由协议版本、状态码（表示请求成功或失败的数字代 码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主 体构成。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7dfd825ad40ee?w=810&h=416&f=png&s=159826)

##### HTTP 是不保存状态的协议

在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。

HTTP 协议自身不具备保存之前发送过的请求或响应的功能 

这是为了 更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设 计成如此简单的。

HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。

##### 请求 URI 定位资源

HTTP 协议使用 URI 让客户端定位到资源 

指定请求 URI 的方式有很多：

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f8edeb6c9f36?w=742&h=409&f=png&s=107805)

对服务器本身发起请求，可以 用一个 * 来代替请求 URI。

下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fb501451e8dc?w=857&h=72&f=png&s=6046)

##### 告知服务器意图的 HTTP 方法

绍 HTTP/1.1 中可使用的方法：

1. GET ：获取资源 

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。

例子 ：

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f91da21ec13a?w=376&h=130&f=png&s=17276)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fb241dc42e25?w=1230&h=240&f=png&s=91958)

2. POST：传输实体主体 

虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。

例子：

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f9386dfe77f8?w=584&h=163&f=png&s=30810)

3. PUT：传输文件 

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。
36
但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f94f29f2a1ff?w=938&h=322&f=png&s=66993)

4. HEAD：获得报文首部

HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f95ff05e7c69?w=725&h=194&f=png&s=31112)

5. DELETE：删除文件 

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。

但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f978ea5c2e4a?w=916&h=198&f=png&s=43162)

6. OPTIONS：询问支持的方法 

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7f984ce69ff40?w=767&h=242&f=png&s=44353)

7. TRACE：追踪路径 

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。
发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fa315f749961?w=626&h=207&f=png&s=23715)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fa36b3044427?w=586&h=175&f=png&s=26238)

8. CONNECT：要求用隧道协议连接代理

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输。 

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fa4e6c6665bc?w=730&h=184&f=png&s=38234)

##### 使用方法下达命令

方法名区分大 小写，注意要用大写字母。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fa62b8c18eee?w=976&h=645&f=png&s=115016)

##### 持久连接节省通信量

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。

**持久连接**（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。在建立 1 次 TCP 连接后进行多次请求和响应的交 互

减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。

在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。

除了服务器端，客 户端也需要支持持久连接。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fa9591bf1602?w=925&h=750&f=png&s=423665)

**管线化** 

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从 前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术 出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待 响应了。

**使用 Cookie 的状态管理**

无状态协议当然也有它的优点。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。

Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7faf2d1e38407?w=915&h=710&f=png&s=130977)

## 3.HTTP 报文内的 HTTP 信息

HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回 客户端的响应。

##### HTTP 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。

请求端（客户端）的 HTTP 报文叫做**请求报文**，响应端（服务器端）的叫做**响应报文**。

 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文 本。
HTTP 报文大致可分为**报文首部**和**报文主体**两块。两者由最初出现的 空行（CR+LF）来划分。

通常，并不一定要有报文主体。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fb8767e89106?w=940&h=334&f=png&s=169418)

##### 请求报文及响应报文的结构

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fb9902ec442a?w=970&h=496&f=png&s=259391)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fbb0417cc38a?w=944&h=821&f=png&s=660786)**请求行**
包含用于请求的方法，请求 URI 和 HTTP 版本。
**状态行**
包含表明响应结果的状态码，原因短语和 HTTP 版本。
**首部字段**
包含表示请求和响应的各种条件和属性的各类首部。

一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首 部。
其他
可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。 

##### 编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多 的 CPU 等资源。

**报文**（message） 

是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。

 实体（entity）
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。

HTTP 报文的主体用于传输请求或响应的实体主体。
通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。

**内容编码**指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

常用的内容编码有以下几种。
gzip（GNU zip）

 compress（UNIX 系统的标准压缩）

 deflate（zlib）

 identity（不进行编码） 

###### 分割发送的分块传输编码 

分块传输编码（Chunked Transfer Coding）：在传输大容量数据时，通过把数据分割成 多块，能够让浏览器逐步显示页面。

分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。
使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编 码前的实体主体。
HTTP/1.1 中存在一种称为**传输编码**（Transfer Coding）的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。 

##### 发送多种数据的多部分对象集合

发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为 采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮 件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明， 就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一 种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的 数据。
相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。
多部分对象集合包含的对象如下：

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fc514886e697?w=923&h=291&f=png&s=47642)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fc5bce387ccb?w=896&h=400&f=png&s=54833)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fc61d69a3dd5?w=897&h=368&f=png&s=54758)

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fc6ae8f4d581?w=873&h=229&f=png&s=38120)

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。

 使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记（例如：-AaB03x、--THIS_STRING_SEPARATES），而在多部分对象集合对 应的字符串的最后插入“--”标记（例如：--AaB03x--、-THIS_STRING_SEPARATES--）作为结束。
多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可 以在某个部分中嵌套使用多部分对象集合。

##### 获取部分内容的范围请求

以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一 个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢 复的机制。所谓恢复是指能从之前下载中断处恢复下载。
要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求（Range Request）。 对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7fcb58e677fd9?w=939&h=470&f=png&s=62688)

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报 文。另外，对于多重范围的范围请求，响应会在首部字段 ContentType 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的 实体内容。 

##### 内容协商返回最合适的内容

同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和 中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。 当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商（Content Negotiation）。

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字 符集、编码方式等作为判断的基准。
包含在请求报文中的某些首部字段（如下）就是判断的基准

Accept

Accept-Charset
Accept-Encoding

 Accept-Language 

Content-Language

**内容协商技术**有以下 3 种类型。 

服务器驱动协商（Server-driven Negotiation）
由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自 动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不 一定能筛选出最优内容。
客户端驱动协商（Agent-driven Negotiation）
由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手 动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选 择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机 版页面。
透明协商（Transparent Negotiation）
是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进 行内容协商的一种方法。

## 4.返回结果的 HTTP 状态 码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。

##### 状态码告知从服务器端返回的请求结果

响应的状态码可描述请求的处理结果，状态码如 200 OK，以 3 位数字和原因短语组成。 

数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。

![](https://user-gold-cdn.xitu.io/2020/1/9/16f888ba69ff4822?w=882&h=327&f=png&s=87969)

只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码， 或服务器端自行创建状态码都没问题。

##### 2XX 成功

2XX 的响应结果表明请求被正常处理了。

###### 200 OK

表示从客户端发来的请求在服务器端被正常处理了。
在响应报文内，随状态码一起返回的信息会因方法的不同而发生改 变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体 作为响应返回（即在响应中只返回首部，不会返回实体的主体部 分）。

###### 204 No Content

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。另外，也不允许返回任何实体的主体。比如， 当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面 不发生更新。
一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

###### 206 Partial Content

该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 

##### 3XX 重定向

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请 求。

###### 301 Moved Permanently

**永久性重定向**。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就 会产生 301 状态码。

![](https://user-gold-cdn.xitu.io/2020/1/10/16f8e89bcc587868?w=925&h=60&f=png&s=8182)

###### 302 Found

**临时性重定向**。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不 是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会 像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码 的页面对应的 URI。 

###### 303 See Other

该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次 发送。
> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使 用时大家都会这么做。

###### 304 Not Modified

该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。
附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。 

###### 307 Temporary Redirect 

临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响 应时的行为，每种浏览器有可能出现不同的情况。 

##### 4XX 客户端错误

###### 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态 码。

###### 401 Unauthorized

该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。 返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。

###### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要 给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。
未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发 送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。 

###### 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。 

##### 5XX 服务器错误

###### 500 Internal Server Error

该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 

###### 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

> 状态码和状况的不一致
> 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。 比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种 情况也经常遇到。

## 5.与 HTTP 协作的 Web 服 务器

一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路 径上的中转服务器提升传输效率。

##### 用单台虚拟主机实现多个域名

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提 供 Web 托管服务（Web Hosting Service）的供应商，可以用一台服务 器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网 站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功 能。
即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以 假想已具有多台服务器。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名 的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指 定主机名或域名的 URI。 

##### 通信数据转发程序 ：代理、网关、隧 道

1. 代理

   代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时 也接收服务器返回的响应并转发给客户端。代理不改变请求 URI，会直接发送给前方持有资源的目标服务 器。

   在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会 经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。

   代理有多种使用方法，按两种基准分类。

   一种是是否使用缓存，另一 种是是否会修改报文。
   **缓存代理**
   代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本 （缓存）保存在代理服务器上。
   当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获 取资源，而是将之前缓存的资源作为响应返回。
   **透明代理**
   转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 （Transparent Proxy）。反之，对报文内容进行加工的代理被称为非 透明代理。

2. 网关
   网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请 求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客 户端可能都不会察觉，自己的通信目标是一个网关。

   利用网关可以由 HTTP 请求转化为其他协议通信

3. 隧道
   隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方 通信连接的应用程序。

   隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。
   隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。

##### 　保存资源的缓存

缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因 此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处 理相同的请求了。

###### 缓存的有效期限

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源 服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从 源服务器上获取“新”资源。

###### 客户端的缓存

缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件 

## 6.HTTP 首部

